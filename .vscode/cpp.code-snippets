{
	"n": {
		"prefix": "/n",
		"body": ["<< '\\n';"]
	},
	"stdin": {
		"prefix": "stdin",
		"body": [
			"#include <bits/stdc++.h>",
			"#define rep(i,n) for(ll i=0;i<(n);i++)",
			"#define all(x) (x).begin(), (x).end()",
			"using ll = long long;",
			"using namespace std;",
			"template <typename T>",
			"using vec = std::vector<T>;",
			"",
			"int main() {",
			"    int ${1:N};",
			"    cin >> N;",
			"    $2",
			"    ",
			"}"
		]
	},
	"mint MOD計算": {
		"prefix": "mint",
		"body": [
			"const ll MOD = 1000000007;",
			"",
			"struct mint {",
			"    ll x;",
			"    mint(ll x = 0) : x((x % MOD + MOD) % MOD) {",
			"    }",
			"    mint operator-() const {",
			"        return mint(-x);",
			"    }",
			"    mint &operator+=(const mint a) {",
			"        if ((x += a.x) >= MOD) x -= MOD;",
			"        return *this;",
			"    }",
			"    mint &operator-=(const mint a) {",
			"        if ((x += MOD - a.x) >= MOD) x -= MOD;",
			"        return *this;",
			"    }",
			"    mint &operator*=(const mint a) {",
			"        (x *= a.x) %= MOD;",
			"        return *this;",
			"    }",
			"    mint operator+(const mint a) const {",
			"        mint res(*this);",
			"        return res += a;",
			"    }",
			"    mint operator-(const mint a) const {",
			"        mint res(*this);",
			"        return res -= a;",
			"    }",
			"    mint operator*(const mint a) const {",
			"        mint res(*this);",
			"        return res *= a;",
			"    }",
			"    mint pow(ll t) const {",
			"        if (!t) return 1;",
			"        mint a = pow(t/2);",
			"        a *= a;",
			"        if (t & 1) a *= *this;",
			"        return a;",
			"    }",
			"",
			"    // for prime MOD",
			"    mint inv() const {",
			"        return pow(MOD - 2);",
			"    }",
			"    mint &operator/=(const mint a) {",
			"        return (*this) *= a.inv();",
			"    }",
			"    mint operator/(const mint a) const {",
			"        mint res(*this);",
			"        return res /= a;",
			"    }",
			"};",
			"",
			"ostream &operator<<(ostream &os, const mint &a) {",
			"    return os << a.x;",
			"}"
		]
	},
	"gcdとlcm": {
		"prefix": "gcd_lcm",
		"description": "最大公約数/最小公倍数を求める",
		"body": [
			"ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}",
			"ll lcm(ll a,ll b){return a/gcd(a,b)*b;}"
		]
	},
	"nCk 組み合わせ": {
		"prefix": "nck",
		"description": "組み合わせを求める",
		"body": [
			"// 下記で初期化 1000009くらいが最大か",
			"// → combination nCk(1000009);",
			"// そのあとは自由に使える",
			"// → nCk(100,3) → 161700",
			"",
			"struct combination {",
			"    vector<mint> fact, ifact;",
			"    combination(int n) : fact(n + 1), ifact(n + 1) {",
			"        assert(n < MOD);",
			"        fact[0] = 1;",
			"        for (int i = 1; i <= n; ++i)",
			"            fact[i] = fact[i - 1] * i;",
			"        ifact[n] = fact[n].inv();",
			"        for (int i = n; i >= 1; --i)",
			"            ifact[i - 1] = ifact[i] * i;",
			"    }",
			"    mint operator()(int n, int k) {",
			"        if (k < 0 || k > n) return 0;",
			"        return fact[n] * ifact[k] * ifact[n - k];",
			"    }",
			"};"
		]
	},
	"counting 数え上げ": {
		"prefix": "counting",
		"description": "順列、組み合わせ、階乗など",
		"body": [
			"struct counting {",
			"    vector<mint> fact, ifact;",
			"    counting(int n) : fact(n + 1), ifact(n + 1) {",
			"        assert(n < MOD);",
			"        fact[0] = 1;",
			"        for (int i = 1; i <= n; ++i)",
			"            fact[i] = fact[i - 1] * i;",
			"        ifact[n] = fact[n].inv();",
			"        for (int i = n; i >= 1; --i)",
			"            ifact[i - 1] = ifact[i] * i;",
			"    }",
			"    mint nCk(int n, int k) {",
			"        if (k < 0 || k > n) return 0;",
			"        return fact[n] * ifact[k] * ifact[n - k];",
			"    }",
			"    mint nPk(int n, int k){",
			"        return fact[n]*ifact[n-k];",
			"    }",
			"    mint factorial (int n){",
			"        return fact[n];",
			"    }",
			"} c(1000009);",
			"// c.nCk(100,10)　や c.nPk(M,N)などで使う",
			"// 階乗は c.factorial(5) → 120",
		]
	},
	"素因数分解": {
		"prefix": "sieve",
		"description": "素因数分解",
		"body": [
			"struct Sieve {",
			"    int n;",
			"    vector<int> f, primes;",
			"    Sieve(int n = 1) : n(n), f(n + 1) {",
			"        f[0] = f[1] = -1;",
			"        for (ll i = 2; i <= n; ++i) {",
			"            if (f[i]) continue;",
			"            primes.push_back(i);",
			"            f[i] = i;",
			"            for (ll j = i * i; j <= n; j += i) {",
			"                if (!f[j]) f[j] = i;",
			"            }",
			"        }",
			"    }",
			"    bool isPrime(int x) {",
			"        return f[x] == x;",
			"    }",
			"    vector<int> factorList(int x) {",
			"        vector<int> res;",
			"        while (x != 1) {",
			"            res.push_back(f[x]);",
			"            x /= f[x];",
			"        }",
			"        return res;",
			"    }",
			"    vector<pair<int, int>> factor(int x) {",
			"        vector<int> fl = factorList(x);",
			"        if (fl.size() == 0) return {};",
			"        vector<pair<int, int>> res(1, pair<int, int>(fl[0], 0));",
			"        for (int p : fl) {",
			"            if (res.back().first == p) {",
			"                res.back().second++;",
			"            } else {",
			"                res.emplace_back(p, 1);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
			"",
			"// main内で、「Sieve sieve(1e6);」等で初期化",
			"//",
			"// こうやって使う",
			"//  for(auto e:sieve.factor(2020)){",
			"//            cout << e.first << \" \" << e.second << endl;",
			"//  }",
			"// ↓",
			"// 2 2",
			"// 5 1",
			"// 101 1",
			"//",
		]
	},
	"debug": {
		"prefix": "debug",
		"body": [
			"#define debug(x) cout << #x << \"=\" << x << endl;",
			"#define vdebug(v) { cout << #v << \"=\" << endl; rep(i_debug, v.size()) { cout << v[i_debug] << \",\";}cout << endl; }",
			"#define mdebug(m) { cout << #m << \"=\" << endl; rep(i_debug, m.size()) { rep(j_debug, m[i_debug].size()) { cout << m[i_debug][j_debug] << \",\"; } cout << endl; } }",
		]
	},
	"cout": {
		"prefix": "cout",
		"description": "標準出力",
		"body": [
			"cout << ${1:ans} << endl;"
		]
	},
	"rep": {
		"prefix": "rep",
		"description": "繰り返し",
		"body": [
			"rep(i,${1:N}) {",
			"    $2",
			"}",
		]
	},
	"repcin": {
		"prefix": "repcin",
		"body": [
			"rep(i,N) cin >> A[i];"
		]
	},
	"BIT": {
		"prefix": "BIT",
		"description": "Binary Indexed Tree (Fenwick Tree)",
		"body": [
			"// BIT<ll> bit(N); などで初期化",
			"template <typename T> struct BIT {",
			"    int n;",
			"    vector<T> bit;",
			"    BIT(int n_) : n(n_ + 1), bit(n, 0) {",
			"    }",
			"",
			"    // bit.add(1,10)で「1」に10を足せる。",
			"    // 中身は1-indexedなので、「0」を受け取ってはいけない.",
			"    void add(int i, T x) {",
			"        if (i == 0) {",
			"            cout << \"BIT add ERROR\" << endl;",
			"            exit(1);",
			"        }",
			"        for (int idx = i; idx < n; idx += (idx & -idx)) {",
			"            bit[idx] += x;",
			"        }",
			"    }",
			"",
			"    // bit.sum(3)で、「1〜3」の値の合計を返す。",
			"    // bit.sum(0)は0を返す。",
			"    T sum(int i) {",
			"        T s(0);",
			"        ",
			"        for (int idx = i; idx > 0; idx -= (idx & -idx)) {",
			"            s += bit[idx];",
			"        }",
			"        return s;",
			"    }",
			"};",
		]
	},
	"struct template": {
		"prefix": "strc",
		"description": "並べ替え付きstruct",
		"body": [
			"struct P {",
			"    int a;",
			"    int b;",
			"",
			"    bool operator<(const P &another) const {",
			"        if (b == another.b)",
			"            return a < another.a;",
			"        else",
			"            return b < another.b;",
			"    };",
			"};"
		]
	},
	"kaibun": {
		"prefix": "kaibun",
		"description": "回文かどうかを判定する関数",
		"body": [
			"bool f(string s) {",
			"    string rs = s;",
			"    reverse(all(rs));",
			"    return s == rs;",
			"}"
		]
	},
	"vector": {
		"prefix": "vec",
		"description": "vectorの省略形",
		"body": [
			"template<typename T> using vec = std::vector<T>;"
		]
	},
	"bit": {
		"prefix": "bit",
		"description": "bit演算のテンプレ",
		"body": [
			"rep(i,1<<N){",
			"    int tmpans = 0;",
			"    rep(j,N){\n",
			"        // j桁目に1が立ってなければcontinue",
			"        if(!(i&1<<j)) continue;",
			"        tmpans += C[j];",
			"    }",
			"}"
		]
	},
	"deg_to_rad": {
		"prefix": "deg_to_rad",
		"description": "度数をラジアン（π）へ",
		"body": [
			"// 度数（°）をラジアン（π）へ",
			"// 度数をラジアンに変換することで、cos(rad)など三角関数が使えるようになるよ",
			"// 標準入力とか、計算途中とか、ちゃんとdoubleでキャストすること",
			"double deg_to_rad(double degree){",
			"    double pi = acos(-1);",
			"    double rad = pi*degree/180;",
			"    return rad;",
			"}",
		]
	},
	"setprecision": {
		"prefix": "setprecision",
		"description": "小数点以下を指定",
		"body": "cout << fixed << setprecision(15);"
	},
	"YesNo": {
		"prefix": "YesNo",
		"description": "YesNoで回答する場合の標準出力",
		"body": "cout << ((${1:ans})?\"Yes\":\"No\") << endl;"
	}
}